<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>Supabase Storage PDF Upload + Folders</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<style>
	:root {
		--bg: #f7f7f8;
		--panel: #ffffff;
		--accent: #111827;
		--text: #111827;
		--muted: #6b7280;
		--danger: #dc2626;
		--success: #16a34a;
		--border: #e5e7eb
	}

	body {
		margin: 0;
		background: var(--bg);
		color: var(--text);
		font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
		min-height: 100vh
	}

	.container {
		max-width: 1140px;
		margin: 40px auto;
		padding: 0 20px
	}

	h1 {
		font-size: 1.6rem;
		margin: 0 0 8px
	}

	p {
		color: var(--muted);
		margin: 0 0 18px
	}

	.panel {
		background: var(--panel);
		border: 1px solid var(--border);
		border-radius: 16px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
		padding: 18px
	}

	.grid {
		display: grid;
		grid-template-columns: 1fr;
		gap: 16px
	}

	@media(min-width:1100px) {
		.grid {
			grid-template-columns: 1fr 1fr
		}
	}

	.dropzone {
		border: 2px dashed var(--border);
		border-radius: 14px;
		padding: 28px;
		text-align: center;
		transition: border-color .2s, background .2s;
		cursor: pointer;
		background: #fafafa
	}

	.dropzone.dragover {
		border-color: var(--accent);
		background: #f3f4f6
	}

	.hint {
		color: var(--muted);
		font-size: .95rem;
		margin-top: 6px
	}

	.controls {
		margin-top: 14px;
		display: flex;
		gap: 10px;
		justify-content: center;
		flex-wrap: wrap
	}

	.btn {
		appearance: none;
		border: 1px solid var(--border);
		background: #ffffff;
		color: var(--text);
		padding: 10px 14px;
		border-radius: 10px;
		cursor: pointer;
		font-weight: 600;
		transition: transform .06s ease, background .2s, box-shadow .2s
	}

	.btn:hover {
		background: #f9fafb;
		box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04)
	}

	.btn:active {
		transform: translateY(1px)
	}

	.btn.primary {
		border-color: var(--accent);
		background: var(--accent);
		color: #ffffff
	}

	.status {
		margin-top: 10px;
		min-height: 18px;
		font-size: .95rem
	}

	.status.ok {
		color: var(--success)
	}

	.status.err {
		color: var(--danger)
	}

	.gallery {
		display: grid;
		grid-template-columns: 1fr;
		gap: 14px;
		margin-top: 8px
	}

	.card {
		background: var(--panel);
		border: 1px solid var(--border);
		border-radius: 12px;
		overflow: hidden
	}

	.card-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 10px;
		padding: 10px 12px;
		border-bottom: 1px solid var(--border);
		background: #f9fafb
	}

	.name {
		overflow: hidden;
		white-space: nowrap;
		text-overflow: ellipsis;
		font-weight: 600;
		font-size: .95rem
	}

	.links a {
		color: var(--accent);
		text-decoration: none;
		font-weight: 600;
		margin-left: 10px
	}

	.viewer {
		width: 100%;
		height: 380px;
		border: 0;
		display: none;
		background: #f3f4f6
	}

	.empty {
		color: var(--muted);
		padding: 10px;
		font-style: italic
	}

	.small {
		font-size: .9rem;
		color: var(--muted)
	}

	.section-title {
		display: flex;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 8px
	}

	.row {
		display: flex;
		gap: 16px;
		flex-wrap: wrap
	}

	.col {
		flex: 1 1 320px
	}

	.input {
		width: 100%;
		padding: 10px 12px;
		border: 1px solid var(--border);
		border-radius: 10px;
		background: #fff
	}

	.label {
		font-size: .9rem;
		color: var(--muted);
		margin-bottom: 6px
	}

	.tree {
		border: 1px solid var(--border);
		border-radius: 12px;
		padding: 10px;
		max-height: 420px;
		overflow: auto;
		background: #fafafa
	}

	.tree ul {
		list-style: none;
		margin: 0;
		padding-left: 16px
	}

	.tree li {
		margin: 4px 0
	}

	.tree .node {
		display: flex;
		align-items: center;
		gap: 8px
	}

	.badge {
		display: inline-block;
		font-size: .75rem;
		padding: 2px 8px;
		border-radius: 999px;
		border: 1px solid var(--border);
		background: #fff;
		color: var(--muted)
	}

	.pathbar {
		font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		background: #f3f4f6;
		border: 1px dashed var(--border);
		border-radius: 8px;
		padding: 6px 8px;
		color: #374151
	}

	.kv {
		display: flex;
		align-items: center;
		gap: 8px
	}

	.kv input {
		flex: 1
	}

	.toolbar {
		display: flex;
		gap: 8px;
		flex-wrap: wrap;
		margin-top: 10px
	}

	hr.sep {
		border: 0;
		border-top: 1px solid var(--border);
		margin: 12px 0
	}

	.select {
		padding: 10px 12px;
		border: 1px solid var(--border);
		border-radius: 10px;
		background: #fff;
		width: 100%
	}

	.modal {
		position: fixed;
		inset: 0;
		background: rgba(0, 0, 0, 0.5);
		display: none;
		align-items: center;
		justify-content: center;
		padding: 20px;
		z-index: 1000
	}

	.modal .dialog {
		background: #fff;
		border-radius: 14px;
		max-width: 720px;
		width: 100%;
		padding: 16px;
		border: 1px solid var(--border)
	}

	.modal .dialog .header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 10px
	}

	.modal .dialog .body {
		display: grid;
		grid-template-columns: 1fr;
		gap: 12px
	}

	@media(min-width:800px) {
		.modal .dialog .body {
			grid-template-columns: 1fr 1fr
		}
	}

	.modal .actions {
		display: flex;
		justify-content: flex-end;
		gap: 10px;
		margin-top: 12px
	}

	.file-item {
		display: flex;
		align-items: center;
		gap: 8px
	}

	.file-item .fname {
		flex: 1;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap
	}

	.muted {
		color: var(--muted)
	}
	</style>
</head>

<body>
	<div class="container">
		<h1>PDF Uploader (Supabase Storage)</h1>
		<p>Drop a PDF or choose a file. Manage folders, place PDFs into folders, and view the full structure.</p>
		<div class="grid">
			<div class="panel">
				<div id="dropzone" class="dropzone">
					<div><strong>Drop PDF here</strong> or click to choose</div>
					<div class="hint">Max 20 MB • Only application/pdf</div> <input id="fileInput" type="file" accept="application/pdf" hidden />
				</div>
				<div class="controls"> <button id="chooseBtn" class="btn">Choose PDF</button> <select id="uploadPathSelect" class="select" style="max-width:320px"></select> <button id="uploadBtn" class="btn primary">Upload</button> </div>
				<div id="status" class="status"></div>
				<div class="small">Bucket: <code>pdfs</code></div>
			</div>
			<div class="panel">
				<div class="section-title">
					<h2 style="margin:0;font-size:1.1rem;">Uploaded PDFs</h2>
					<div class="row" style="gap:8px"> <button id="refreshBtn" class="btn">Refresh</button> </div>
				</div>
				<div id="gallery" class="gallery"></div>
				<div id="emptyState" class="empty" style="display:none;">No PDFs yet.</div>
			</div>
		</div>
		<div class="grid" style="margin-top:16px">
			<div class="panel col">
				<div class="section-title">
					<h2 style="margin:0;font-size:1.1rem;">Folder Manager</h2> <span class="badge">JSONBin</span>
				</div>
				<div class="label">Selected Path</div>
				<div id="selectedPath" class="pathbar">/</div>
				<div class="toolbar"> <input id="newFolderName" class="input" placeholder="New folder name" style="max-width:240px" /> <button id="addFolderBtn" class="btn">Add Here</button> <button id="renameFolderBtn" class="btn">Rename</button> <button id="removeFolderBtn" class="btn">Remove</button> </div>
				<div class="small" style="margin-top:6px">Empty folders are stored in JSONBin. Files appear under their actual storage paths.</div>
				<div class="small" style="margin-top:6px">Bin ID: <code>68b9d3d8d0ea881f4071c182</code></div>
			</div>
			<div class="panel col">
				<div class="section-title">
					<h2 style="margin:0;font-size:1.1rem;">Structure</h2> <button id="reloadStructureBtn" class="btn">Reload</button>
				</div>
				<div id="structureTree" class="tree"></div>
			</div>
		</div>
	</div>
	<div id="pathModal" class="modal">
		<div class="dialog">
			<div class="header">
				<div style="font-weight:700">Move PDF</div> <button id="closePathModal" class="btn">Close</button>
			</div>
			<div class="body">
				<div>
					<div class="label">Current</div>
					<div id="currentFilePath" class="pathbar"></div>
					<div class="label" style="margin-top:8px">Choose New Path</div>
					<div id="modalTree" class="tree"></div>
				</div>
				<div>
					<div class="label">Or type a new path</div> <input id="typedPath" class="input" placeholder="e.g. Reports/2025/Q1" />
					<div class="small" style="margin-top:6px">Use "/" to create nested folders. Leave empty for root.</div>
					<hr class="sep" />
					<div class="file-item"> <span class="muted">File:</span> <span id="modalFileName" class="fname"></span> </div>
					<div class="label" style="margin-top:8px">Resulting Key</div>
					<div id="resultingKey" class="pathbar"></div>
				</div>
			</div>
			<div class="actions"> <button id="moveConfirmBtn" class="btn primary">Move</button> </div>
		</div>
	</div>
	<script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js" crossorigin="anonymous"></script>
	<script>
	const SUPABASE_URL = "https://vehpvfcjceglrftdjlje.supabase.co";
	const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZlaHB2ZmNqY2VnbHJmdGRqbGplIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcwMTQ5NDEsImV4cCI6MjA3MjU5MDk0MX0.yqZTnMDvCuCqTD9ptkj_Nc-qsvKne-06k8gaRtnYNxc";
	const BUCKET = "pdfs";
	const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
	const dropzone = document.getElementById('dropzone');
	const fileInput = document.getElementById('fileInput');
	const chooseBtn = document.getElementById('chooseBtn');
	const uploadBtn = document.getElementById('uploadBtn');
	const statusEl = document.getElementById('status');
	const galleryEl = document.getElementById('gallery');
	const emptyStateEl = document.getElementById('emptyState');
	const refreshBtn = document.getElementById('refreshBtn');
	const uploadPathSelect = document.getElementById('uploadPathSelect');
	const structureTreeEl = document.getElementById('structureTree');
	const reloadStructureBtn = document.getElementById('reloadStructureBtn');
	const selectedPathEl = document.getElementById('selectedPath');
	const newFolderNameInput = document.getElementById('newFolderName');
	const addFolderBtn = document.getElementById('addFolderBtn');
	const renameFolderBtn = document.getElementById('renameFolderBtn');
	const removeFolderBtn = document.getElementById('removeFolderBtn');
	const pathModal = document.getElementById('pathModal');
	const closePathModalBtn = document.getElementById('closePathModal');
	const modalTreeEl = document.getElementById('modalTree');
	const typedPathInput = document.getElementById('typedPath');
	const resultingKeyEl = document.getElementById('resultingKey');
	const currentFilePathEl = document.getElementById('currentFilePath');
	const modalFileNameEl = document.getElementById('modalFileName');
	const moveConfirmBtn = document.getElementById('moveConfirmBtn');
	const BIN_ID = "68b9d3d8d0ea881f4071c182";
	const BIN_URL_LATEST = `https://api.jsonbin.io/v3/b/${BIN_ID}/latest`;
	const BIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
	const JSONBIN_KEY = "$2a$10$9sO/ja29sMebpWNvsWmp5.dJ6lv7CPeLBMRFaA/cAEwz42ii6qlCS";
	let selectedFile = null;
	let folderTree = {
		folders: []
	};
	let selectedFolderPath = "";
	let allFiles = [];
	let moveContext = {
		fromKey: "",
		baseName: "",
		toPath: ""
	};

	function setStatus(msg, type) {
		statusEl.className = 'status' + (type ? ' ' + type : '');
		statusEl.textContent = msg || ''
	}

	function sanitizeName(name) {
		const base = name.replace(/\s+/g, '_').replace(/[^\w.\-]/g, '');
		return base.replace(/^\.+/, '')
	}

	function uid() {
		return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8)
	}

	function formatDisplayName(filename) {
		let name = filename.replace(/^[^/]+\/+/, '');
		name = name.replace(/^[^_]+_/, '');
		name = name.replace(/\.pdf$/i, '');
		name = name.replace(/_/g, ' ');
		name = name.replace(/\s+/g, ' ').trim();
		return name
	}

	function pathJoin(a, b) {
		if(!a) return b || '';
		if(!b) return a;
		return a.replace(/\/+$/, '') + '/' + b.replace(/^\/+/, '')
	}

	function getDirname(key) {
		const i = key.lastIndexOf('/');
		return i === -1 ? '' : key.slice(0, i)
	}

	function getBasename(key) {
		const i = key.lastIndexOf('/');
		return i === -1 ? key : key.slice(i + 1)
	}

	function uniquePathsFromTree(tree, prefix = "") {
		let arr = [""];
		for(const f of tree.folders || []) {
			const p = pathJoin(prefix, f.name);
			arr.push(p);
			arr = arr.concat(uniquePathsFromTree({
				folders: f.children || []
			}, p))
		}
		return Array.from(new Set(arr))
	}

	function ensurePathInTree(path) {
		const parts = (path || "").split('/').filter(Boolean);
		let node = folderTree;
		for(const part of parts) {
			let next = (node.folders || []).find(x => x.name === part);
			if(!next) {
				if(!node.folders) node.folders = [];
				next = {
					name: part,
					children: []
				};
				node.folders.push(next)
			}
			node = {
				folders: next.children
			}
		}
	}
	async function jsonbinFetchLatest() {
		try {
			const r = await fetch(BIN_URL_LATEST);
			if(!r.ok) return null;
			const j = await r.json();
			return j.record || null
		} catch {
			return null
		}
	}
	async function jsonbinSave(record) {
		if(!JSONBIN_KEY) return false;
		const r = await fetch(BIN_URL, {
			method: 'PUT',
			headers: {
				'Content-Type': 'application/json',
				'X-Master-Key': JSONBIN_KEY
			},
			body: JSON.stringify(record)
		});
		if(!r.ok) {
			return false
		}
		return true
	}

	function renderUploadPathSelect() {
		const paths = uniquePathsFromTree(folderTree);
		uploadPathSelect.innerHTML = '';
		for(const p of paths) {
			const opt = document.createElement('option');
			opt.value = p;
			opt.textContent = p ? '/' + p : '/(root)';
			uploadPathSelect.appendChild(opt)
		}
	}

	function renderSelectedPath() {
		selectedPathEl.textContent = selectedFolderPath ? '/' + selectedFolderPath : '/'
	}

	function renderTreeWithFiles(container, tree, files, clickFolderCb) {
		container.innerHTML = '';
		const rootUl = document.createElement('ul');
		container.appendChild(rootUl);

		function liFolder(path, name) {
			const li = document.createElement('li');
			const row = document.createElement('div');
			row.className = 'node';
			const btn = document.createElement('button');
			btn.className = 'btn';
			btn.style.padding = '4px 8px';
			btn.textContent = '▾';
			btn.dataset.expanded = '1';
			btn.onclick = () => {
				const exp = btn.dataset.expanded === '1';
				btn.dataset.expanded = exp ? '0' : '1';
				btn.textContent = exp ? '▸' : '▾';
				content.style.display = exp ? 'none' : 'block'
			};
			const a = document.createElement('a');
			a.href = "#";
			a.textContent = name || '(root)';
			a.onclick = (e) => {
				e.preventDefault();
				clickFolderCb(path)
			};
			row.appendChild(btn);
			row.appendChild(a);
			li.appendChild(row);
			const content = document.createElement('div');
			content.style.marginLeft = '16px';
			li.appendChild(content);
			return {
				li,
				content
			}
		}

		function addFolderNode(parentUl, nodePath, node) {
			const {
				li,
				content
			} = liFolder(nodePath, node.name);
			parentUl.appendChild(li);
			const subUl = document.createElement('ul');
			content.appendChild(subUl);
			for(const child of (node.children || [])) {
				const childPath = pathJoin(nodePath, child.name);
				addFolderNode(subUl, childPath, child)
			}
			const subFiles = files.filter(f => getDirname(f.key) === nodePath);
			if(subFiles.length) {
				const filesUl = document.createElement('ul');
				for(const f of subFiles) {
					const li = document.createElement('li');
					const row = document.createElement('div');
					row.className = 'file-item';
					const span = document.createElement('span');
					span.className = 'fname';
					span.textContent = getBasename(f.key);
					const a = document.createElement('a');
					a.href = f.publicUrl;
					a.target = '_blank';
					a.rel = 'noopener';
					a.textContent = 'Open';
					a.style.marginLeft = '8px';
					const btn = document.createElement('button');
					btn.className = 'btn';
					btn.style.padding = '4px 8px';
					btn.textContent = 'Move';
					btn.onclick = () => openPathModal(f.key);
					row.appendChild(span);
					row.appendChild(a);
					row.appendChild(btn);
					li.appendChild(row);
					filesUl.appendChild(li)
				}
				content.appendChild(filesUl)
			}
		}
		const inferredFolders = new Set(files.map(f => getDirname(f.key)).filter(Boolean));
		for(const p of inferredFolders) {
			ensurePathInTree(p)
		}
		const header = liFolder('', '(root)');
		rootUl.appendChild(header.li);
		const rootFiles = files.filter(f => getDirname(f.key) === '');
		if(rootFiles.length) {
			const filesUl = document.createElement('ul');
			for(const f of rootFiles) {
				const li = document.createElement('li');
				const row = document.createElement('div');
				row.className = 'file-item';
				const span = document.createElement('span');
				span.className = 'fname';
				span.textContent = getBasename(f.key);
				const a = document.createElement('a');
				a.href = f.publicUrl;
				a.target = '_blank';
				a.rel = 'noopener';
				a.textContent = 'Open';
				a.style.marginLeft = '8px';
				const btn = document.createElement('button');
				btn.className = 'btn';
				btn.style.padding = '4px 8px';
				btn.textContent = 'Move';
				btn.onclick = () => openPathModal(f.key);
				row.appendChild(span);
				row.appendChild(a);
				row.appendChild(btn);
				li.appendChild(row);
				filesUl.appendChild(li)
			}
			header.content.appendChild(filesUl)
		}
		const subUl = document.createElement('ul');
		header.content.appendChild(subUl);
		for(const f of folderTree.folders || []) {
			addFolderNode(subUl, f.name, f)
		}
	}

	function renderFolderManagerTree() {
		renderTreeWithFiles(structureTreeEl, folderTree, allFiles, (path) => {
			selectedFolderPath = path || '';
			renderSelectedPath();
			updateUploadSelection(path)
		})
	}

	function updateUploadSelection(path) {
		const opts = [...uploadPathSelect.options];
		const found = opts.find(o => o.value === path);
		if(found) uploadPathSelect.value = path
	}
	dropzone.addEventListener('click', () => fileInput.click());
	chooseBtn.addEventListener('click', () => fileInput.click());
	dropzone.addEventListener('dragover', (e) => {
		e.preventDefault();
		dropzone.classList.add('dragover')
	});
	dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
	dropzone.addEventListener('drop', (e) => {
		e.preventDefault();
		dropzone.classList.remove('dragover');
		if(!e.dataTransfer.files || !e.dataTransfer.files.length) return;
		const file = e.dataTransfer.files[0];
		handleSelect(file)
	});
	fileInput.addEventListener('change', (e) => {
		const file = e.target.files && e.target.files[0];
		handleSelect(file)
	});

	function handleSelect(file) {
		if(!file) return;
		if(file.type !== 'application/pdf') {
			setStatus('Only PDFs are allowed.', 'err');
			selectedFile = null;
			return
		}
		const maxBytes = 20 * 1024 * 1024;
		if(file.size > maxBytes) {
			setStatus('File too large. Max 20 MB.', 'err');
			selectedFile = null;
			return
		}
		selectedFile = file;
		setStatus(`Selected: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`)
	}
	uploadBtn.addEventListener('click', async () => {
		if(!selectedFile) {
			setStatus('Pick a PDF first.', 'err');
			return
		}
		try {
			await uploadPdf(selectedFile, uploadPathSelect.value || '');
			selectedFile = null;
			fileInput.value = '';
			setStatus('Upload complete.', 'ok');
			await reloadAll()
		} catch (err) {
			setStatus(err.message || 'Upload failed.', 'err')
		}
	});
	refreshBtn.addEventListener('click', reloadAll);
	async function uploadPdf(file, folderPath) {
		setStatus('Uploading…');
		const safeName = sanitizeName(file.name);
		const baseKey = (folderPath ? folderPath + '/' : '') + `${uid()}_${safeName}`;
		const {
			data,
			error
		} = await supabase.storage.from(BUCKET).upload(baseKey, file, {
			contentType: file.type || 'application/pdf',
			cacheControl: '3600',
			upsert: false
		});
		if(error) throw error;
		return data
	}
	async function listRecursive(prefix = "") {
		const out = [];
		async function walk(path) {
			const {
				data,
				error
			} = await supabase.storage.from(BUCKET).list(path, {
				limit: 1000
			});
			if(error) throw error;
			for(const item of data || []) {
				const key = pathJoin(path, item.name);
				if(item.metadata === null) {
					await walk(key)
				} else {
					const {
						data: pub
					} = supabase.storage.from(BUCKET).getPublicUrl(key);
					out.push({
						key,
						publicUrl: pub.publicUrl
					})
				}
			}
		}
		await walk(prefix);
		return out
	}
	async function loadPdfsFlat() {
		galleryEl.innerHTML = '';
		setStatus('Loading…');
		const files = await listRecursive('');
		allFiles = files;
		renderFolderManagerTree();
		if(!files.length) {
			emptyStateEl.style.display = 'block';
			setStatus('');
			return
		}
		emptyStateEl.style.display = 'none';
		for(const f of files) {
			const card = document.createElement('div');
			card.className = 'card';
			const header = document.createElement('div');
			header.className = 'card-header';
			const name = document.createElement('div');
			name.className = 'name';
			name.title = f.key;
			name.textContent = formatDisplayName(getBasename(f.key));
			const links = document.createElement('div');
			links.className = 'links';
			const aOpen = document.createElement('a');
			aOpen.href = f.publicUrl;
			aOpen.target = '_blank';
			aOpen.rel = 'noopener';
			aOpen.textContent = 'Open';
			const aDownload = document.createElement('a');
			aDownload.href = f.publicUrl;
			aDownload.download = '';
			aDownload.textContent = 'Download';
			const btnPath = document.createElement('a');
			btnPath.href = '#';
			btnPath.textContent = 'Path';
			btnPath.onclick = (e) => {
				e.preventDefault();
				openPathModal(f.key)
			};
			links.appendChild(aOpen);
			links.appendChild(aDownload);
			links.appendChild(btnPath);
			header.appendChild(name);
			header.appendChild(links);
			const iframe = document.createElement('iframe');
			iframe.className = 'viewer';
			iframe.src = f.publicUrl + '#view=FitH';
			card.appendChild(header);
			card.appendChild(iframe);
			galleryEl.appendChild(card)
		}
		setStatus('')
	}
	async function loadFolderTree() {
		const rec = await jsonbinFetchLatest();
		folderTree = rec && rec.folders ? rec : {
			folders: []
		};
		renderUploadPathSelect();
		renderFolderManagerTree()
	}
	async function saveFolderTree() {
		await jsonbinSave(folderTree);
		renderUploadPathSelect();
		renderFolderManagerTree()
	}
	reloadStructureBtn.addEventListener('click', reloadAll);
	addFolderBtn.addEventListener('click', async () => {
		const name = (newFolderNameInput.value || '').trim();
		if(!name) {
			setStatus('Enter a folder name.', 'err');
			return
		}
		if(/[\\]/.test(name) || name.includes('/')) {
			setStatus('Folder name cannot contain "/" or "\\".', 'err');
			return
		}
		ensurePathInTree(selectedFolderPath);
		const parts = (selectedFolderPath || "").split('/').filter(Boolean);
		let node = folderTree;
		for(const p of parts) {
			node = (node.folders || []).find(x => x.name === p);
			node = {
				folders: node.children
			}
		}
		if(!node.folders) node.folders = [];
		if(node.folders.find(x => x.name === name)) {
			setStatus('Folder already exists here.', 'err');
			return
		}
		node.folders.push({
			name,
			children: []
		});
		try {
			await saveFolderTree();
			newFolderNameInput.value = '';
			setStatus('Folder created.', 'ok')
		} catch (e) {
			setStatus('Folder saved locally (no JSONBin key).', 'ok')
		}
	});
	renameFolderBtn.addEventListener('click', async () => {
		if(!selectedFolderPath) {
			setStatus('Select a folder to rename.', 'err');
			return
		}
		const newName = (newFolderNameInput.value || '').trim();
		if(!newName) {
			setStatus('Enter a new name.', 'err');
			return
		}
		if(newName.includes('/') || /[\\]/.test(newName)) {
			setStatus('Invalid name.', 'err');
			return
		}
		const parts = selectedFolderPath.split('/').filter(Boolean);
		const oldName = parts.pop();
		const parentPath = parts.join('/');
		let parent = folderTree;
		for(const p of parts) {
			parent = (parent.folders || []).find(x => x.name === p);
			parent = {
				folders: parent.children
			}
		}
		if(!parent.folders) {
			setStatus('Internal error.', 'err');
			return
		}
		if(parent.folders.find(x => x.name === newName)) {
			setStatus('Name already exists.', 'err');
			return
		}
		const nodeObj = (parent.folders || []).find(x => x.name === oldName);
		const oldPrefix = selectedFolderPath;
		const newPrefix = pathJoin(parentPath, newName);
		try {
			await moveAllUnderPrefix(oldPrefix, newPrefix);
			nodeObj.name = newName;
			try {
				await saveFolderTree();
				setStatus('Folder renamed.', 'ok')
			} catch {
				setStatus('Folder renamed locally (no JSONBin key).', 'ok')
			}
			selectedFolderPath = newPrefix;
			renderSelectedPath();
			await reloadAll();
		} catch (e) {
			setStatus(e.message || 'Rename failed.', 'err')
		}
	});
	removeFolderBtn.addEventListener('click', async () => {
		if(!selectedFolderPath) {
			setStatus('Select a folder to remove.', 'err');
			return
		}
		const hasFiles = allFiles.some(f => f.key.startsWith(selectedFolderPath + '/'));
		if(hasFiles) {
			setStatus('Folder not empty. Move files first.', 'err');
			return
		}
		const parts = selectedFolderPath.split('/').filter(Boolean);
		const name = parts.pop();
		const parentPath = parts.join('/');
		let parent = folderTree;
		for(const p of parts) {
			parent = (parent.folders || []).find(x => x.name === p);
			parent = {
				folders: parent.children
			}
		}
		if(!parent.folders) {
			setStatus('Internal error.', 'err');
			return
		}
		const nodeObj = parent.folders.find(x => x.name === name);
		if(nodeObj && nodeObj.children && nodeObj.children.length) {
			setStatus('Folder has subfolders. Remove them first.', 'err');
			return
		}
		parent.folders = parent.folders.filter(x => x.name !== name);
		try {
			await saveFolderTree();
			selectedFolderPath = parentPath;
			renderSelectedPath();
			renderFolderManagerTree();
			renderUploadPathSelect();
			setStatus('Folder removed.', 'ok')
		} catch (e) {
			selectedFolderPath = parentPath;
			renderSelectedPath();
			renderFolderManagerTree();
			renderUploadPathSelect();
			setStatus('Folder removed locally (no JSONBin key).', 'ok')
		}
	});
	async function moveAllUnderPrefix(oldPrefix, newPrefix) {
		const items = allFiles.filter(f => f.key.startsWith(oldPrefix + '/'));
		for(const f of items) {
			const rest = f.key.slice(oldPrefix.length);
			const newKey = (newPrefix ? newPrefix : '') + rest;
			const {
				error
			} = await supabase.storage.from(BUCKET).move(f.key, newKey);
			if(error) throw error
		}
	}

	function openPathModal(key) {
		moveContext.fromKey = key;
		moveContext.baseName = getBasename(key);
		moveContext.toPath = getDirname(key);
		currentFilePathEl.textContent = key;
		modalFileNameEl.textContent = moveContext.baseName;
		typedPathInput.value = getDirname(key);
		updateResultingKeyPreview();
		renderTreeWithFiles(modalTreeEl, folderTree, [], (path) => {
			typedPathInput.value = path || '';
			updateResultingKeyPreview()
		});
		pathModal.style.display = 'flex'
	}

	function closePathModal() {
		pathModal.style.display = 'none'
	}

	function updateResultingKeyPreview() {
		const typed = (typedPathInput.value || '').replace(/^\/+|\/+$/g, '');
		const newKey = (typed ? typed + '/' : '') + moveContext.baseName;
		resultingKeyEl.textContent = newKey;
		moveContext.toPath = typed
	}
	typedPathInput.addEventListener('input', updateResultingKeyPreview);
	closePathModalBtn.addEventListener('click', closePathModal);
	moveConfirmBtn.addEventListener('click', async () => {
		const newKey = (moveContext.toPath ? moveContext.toPath + '/' : '') + moveContext.baseName;
		if(newKey === moveContext.fromKey) {
			closePathModal();
			return
		}
		setStatus('Moving…');
		try {
			if(moveContext.toPath) ensurePathInTree(moveContext.toPath);
			await supabase.storage.from(BUCKET).move(moveContext.fromKey, newKey);
			try {
				await saveFolderTree()
			} catch {}
			setStatus('Moved.', 'ok');
			closePathModal();
			await reloadAll();
		} catch (e) {
			setStatus(e.message || 'Move failed.', 'err')
		}
	});
	async function reloadAll() {
		await loadFolderTree();
		await loadPdfsFlat()
	}
	async function init() {
		await loadFolderTree();
		renderUploadPathSelect();
		renderSelectedPath();
		await loadPdfsFlat()
	}
	init();
	</script>
</body>

</html>
