<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Bunny Storage File Manager</title>
	<style>
	:root {
		--bg: #111;
		--fg: #eee;
		--muted: #bbb;
		--line: #2a2a2a;
		--accent: #666;
		--accent2: #888;
		--danger: #a33;
		--ok: #3a3
	}

	* {
		box-sizing: border-box
	}

	html,
	body {
		height: 100%
	}

	body {
		margin: 0;
		background: #000;
		color: var(--fg);
		font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial, sans-serif
	}

	.container {
		max-width: 1100px;
		margin: 0 auto;
		padding: 20px
	}

	.header {
		display: flex;
		flex-wrap: wrap;
		gap: 10px;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 10px
	}

	.breadcrumb {
		display: flex;
		flex-wrap: wrap;
		gap: 6px;
		align-items: center
	}

	.breadcrumb a {
		color: var(--muted);
		text-decoration: none;
		padding: 2px 6px;
		border: 1px solid var(--line);
		border-radius: 4px
	}

	.breadcrumb a:hover {
		background: #111;
		color: #fff
	}

	.toolbar {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
		align-items: center
	}

	button,
	input[type=file] {
		background: #111;
		color: var(--fg);
		border: 1px solid var(--line);
		padding: 8px 10px;
		border-radius: 6px;
		cursor: pointer
	}

	button:hover {
		background: #151515
	}

	button.primary {
		border-color: var(--accent2)
	}

	button.danger {
		border-color: var(--danger);
		color: #f3caca
	}

	.status {
		min-height: 22px;
		color: var(--muted);
		margin-top: 10px
	}

	.table-wrap {
		border: 1px solid var(--line);
		border-radius: 8px;
		overflow: hidden
	}

	table {
		width: 100%;
		border-collapse: collapse;
		background: #0a0a0a
	}

	th,
	td {
		padding: 10px 12px;
		border-bottom: 1px solid var(--line);
		vertical-align: middle
	}

	th {
		background: #0f0f0f;
		text-align: left;
		color: #ddd;
		font-weight: 600
	}

	tr:hover td {
		background: #0f0f0f
	}

	.type {
		font-size: 12px;
		color: var(--muted)
	}

	.size {
		white-space: nowrap
	}

	.actions {
		display: flex;
		gap: 6px;
		flex-wrap: wrap
	}

	.badge {
		display: inline-block;
		padding: 2px 6px;
		border: 1px solid var(--line);
		border-radius: 999px;
		color: #ccc;
		font-size: 12px
	}

	footer {
		opacity: .7;
		margin-top: 20px;
		font-size: 12px;
		color: #888
	}

	.hidden {
		display: none
	}

	.progress {
		height: 6px;
		background: #151515;
		border: 1px solid var(--line);
		border-radius: 6px;
		overflow: hidden
	}

	.progress>div {
		height: 100%;
		background: linear-gradient(90deg, #444, #777);
		width: 0%
	}

	.small {
		font-size: 12px;
		color: #aaa
	}

	input[type=text] {
		background: #0a0a0a;
		border: 1px solid var(--line);
		color: #fff;
		border-radius: 6px;
		padding: 8px 10px
	}

	.row-title {
		display: flex;
		gap: 8px;
		align-items: center
	}

	.icon {
		width: 18px;
		height: 18px;
		display: inline-block;
		border: 1px solid var(--line);
		border-radius: 4px
	}

	.icon.folder {
		background: #111
	}

	.icon.file {
		background: #090909
	}
	</style>
</head>

<body>
	<div class="container">
		<div class="header">
			<div class="breadcrumb" id="breadcrumb"></div>
			<div class="toolbar"> <button id="btnUp">Up</button> <button id="btnRefresh">Refresh</button> <button id="btnNewFolder" class="primary">New Folder</button> <label> <input type="file" id="fileInput" multiple class="hidden"> <button id="btnUpload" class="primary">Upload Files</button> </label> </div>
		</div>
		<div class="table-wrap">
			<table>
				<thead>
					<tr>
						<th>Name</th>
						<th>Type</th>
						<th class="size">Size</th>
						<th>Modified</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody id="tbody"></tbody>
			</table>
		</div>
		<div class="status" id="status"></div>
		<div id="globalProgress" class="progress hidden">
			<div></div>
		</div>
		<footer>
			<div class="small">Move: enter a destination folder path relative to /1164453/, for example: images or images/2025</div>
		</footer>
	</div>
	<script>
	const CONFIG = {
		zone: 'oazis',
		accessKey: '6b50ffa1-b890-4094-ac781b47265e-19f9-4fd0',
		root: '/1164453/'
	}
	const API = 'https://storage.bunnycdn.com'
	let currentPath = CONFIG.root.endsWith('/') ? CONFIG.root : CONFIG.root + '/';
	const tbody = document.getElementById('tbody');
	const breadcrumbEl = document.getElementById('breadcrumb');
	const statusEl = document.getElementById('status');
	const fileInput = document.getElementById('fileInput');
	const globalProgress = document.getElementById('globalProgress');
	function setStatus(t, ok) {
		statusEl.textContent = t || '';
		statusEl.style.color = ok ? '#8fd18f' : '#bbb'
	}

	function showProgress(p) {
		if(p == null) {
			globalProgress.classList.add('hidden');
			globalProgress.firstElementChild.style.width = '0%';
			return
		}
		globalProgress.classList.remove('hidden');
		globalProgress.firstElementChild.style.width = (Math.max(0, Math.min(100, p))).toFixed(0) + '%'
	}

	function normPath(p) {
		if(!p.startsWith('/')) p = '/' + p;
		if(!p.endsWith('/')) p = p + '/';
		return p
	}

	function cleanPath(p) {
		let s = p.replace(/\/+/g, '/');
		if(!s.startsWith('/')) s = '/' + s;
		return s
	}

	function buildUrl(p) {
		let parts = [CONFIG.zone].concat(cleanPath(p).slice(1).split('/').filter(Boolean));
		let encoded = parts.map(encodeURIComponent).join('/');
		let url = API + '/' + encoded;
		if(p.endsWith('/')) url += '/';
		return url
	}

	function parentPath(p) {
		let s = cleanPath(p);
		if(s === '/') return '/';
		let parts = s.split('/').filter(Boolean);
		if(parts.length <= 1) return '/';
		parts.pop();
		return '/' + parts.join('/') + '/'
	}

	function formatBytes(b) {
		if(b == null || isNaN(b)) return '';
		let u = ['B', 'KB', 'MB', 'GB', 'TB'];
		let i = 0;
		let n = b;
		while(n >= 1024 && i < u.length - 1) {
			n /= 1024;
			i++
		}
		return n.toFixed(n >= 10 || i === 0 ? 0 : 1) + ' ' + u[i]
	}

	function formatDate(d) {
		if(!d) return '';
		let dt = new Date(d);
		if(isNaN(dt)) return '';
		return dt.toLocaleString()
	}
	async function api(path, opts) {
		let o = opts || {};
		o.headers = Object.assign({
			'AccessKey': CONFIG.accessKey
		}, o.headers || {});
		let res = await fetch(buildUrl(path), o);
		return res
	}
	async function list(path) {
		let res = await api(path, {
			headers: {
				'Accept': 'application/json'
			}
		});
		if(!res.ok) throw new Error('List failed ' + res.status);
		return res.json()
	}
	async function createDir(path) {
		let res = await api(path, {
			method: 'PUT',
			headers: {
				'Content-Length': '0',
				'Directory': 'true'
			}
		});
		if(!res.ok && res.status !== 201 && res.status !== 409) throw new Error('Create folder failed ' + res.status)
	}
	async function deleteFile(path) {
		let res = await api(path, {
			method: 'DELETE'
		});
		if(!res.ok && res.status !== 404) throw new Error('Delete failed ' + res.status)
	}
	async function downloadFile(path) {
		let res = await api(path, {});
		if(!res.ok) throw new Error('Download failed ' + res.status);
		return res.blob()
	}
	async function uploadFile(path, file, onProgress) {
		let controller = new AbortController();
		let reader = file.stream().getReader();
		let chunks = [];
		let uploaded = 0;
		const total = file.size;
		for(;;) {
			let {
				done,
				value
			} = await reader.read();
			if(done) break;
			chunks.push(value);
			uploaded += value.byteLength;
			if(onProgress) onProgress(Math.min(100, Math.round(uploaded / Math.max(1, total) * 100)))
		}
		let body = new Blob(chunks, {
			type: 'application/octet-stream'
		});
		let res = await api(path, {
			method: 'PUT',
			headers: {
				'Content-Type': 'application/octet-stream'
			},
			body,
			signal: controller.signal
		});
		if(!res.ok) throw new Error('Upload failed ' + res.status)
	}
	async function ensureDirChain(dir) {
		let p = cleanPath(dir);
		if(!p.endsWith('/')) p += '/';
		let base = '/';
		let segments = p.split('/').filter(Boolean);
		for(let i = 0; i < segments.length; i++) {
			base += segments[i] + '/';
			try {
				await createDir(base)
			} catch (e) {}
		}
	}
	async function deleteFolderRecursively(dir) {
		let items = await list(dir);
		for(let it of items) {
			if(it.IsDirectory) {
				await deleteFolderRecursively(dir + it.ObjectName + '/')
			} else {
				await deleteFile(dir + it.ObjectName)
			}
		}
		await deleteFile(dir)
	}
	async function moveFile(oldPath, newPath) {
		let blob = await downloadFile(oldPath);
		let parent = newPath.split('/').slice(0, -1).join('/') + '/';
		await ensureDirChain(parent);
		let res = await api(newPath, {
			method: 'PUT',
			headers: {
				'Content-Type': 'application/octet-stream'
			},
			body: blob
		});
		if(!res.ok) throw new Error('Move upload failed ' + res.status);
		await deleteFile(oldPath)
	}
	async function moveFolder(oldDir, newDir) {
		let nd = normPath(newDir);
		let od = normPath(oldDir);
		await ensureDirChain(nd);
		await moveFolderRecurse(od, nd);
		await deleteFolderRecursively(od)
	}
	async function moveFolderRecurse(src, dst) {
		let items = await list(src);
		for(let it of items) {
			if(it.IsDirectory) {
				await ensureDirChain(dst + it.ObjectName + '/');
				await moveFolderRecurse(src + it.ObjectName + '/', dst + it.ObjectName + '/')
			} else {
				await moveFile(src + it.ObjectName, dst + it.ObjectName)
			}
		}
	}

	function renderBreadcrumb() {
		breadcrumbEl.innerHTML = '';
		let full = cleanPath(currentPath);
		let parts = full.split('/').filter(Boolean);
		let acc = '/';
		let baseParts = cleanPath(CONFIG.root).split('/').filter(Boolean);
		let startIndex = 0;
		let accParts = [];
		for(let i = 0; i < parts.length; i++) {
			accParts.push(parts[i]);
			acc = '/' + accParts.join('/') + '/';
			let label = i < baseParts.length ? parts[i] : parts[i];
			let a = document.createElement('a');
			a.href = '#';
			a.textContent = label;
			a.onclick = (e) => {
				e.preventDefault();
				currentPath = acc;
				load()
			};
			breadcrumbEl.appendChild(a)
		}
	}

	function rowActions(item, isDir) {
		let wrap = document.createElement('div');
		wrap.className = 'actions';
		if(isDir) {
			let open = document.createElement('button');
			open.textContent = 'Open';
			open.onclick = () => {
				currentPath = cleanPath(currentPath + item.ObjectName + '/');
				load()
			};
			wrap.appendChild(open);
			let rename = document.createElement('button');
			rename.textContent = 'Rename';
			rename.onclick = async () => {
				let nn = prompt('New folder name', item.ObjectName);
				if(!nn || nn === item.ObjectName) return;
				setStatus('Renaming...', true);
				try {
					await moveFolder(currentPath + item.ObjectName + '/', currentPath + nn + '/');
					setStatus('Folder renamed', true);
					load()
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(rename);
			let move = document.createElement('button');
			move.textContent = 'Move';
			move.onclick = async () => {
				let dest = prompt('Destination folder relative to ' + CONFIG.root, '');
				if(dest === null) return;
				dest = dest.trim();
				let destPath = dest ? normPath(CONFIG.root + dest) : currentPath;
				setStatus('Moving folder...', true);
				try {
					await moveFolder(currentPath + item.ObjectName + '/', destPath + item.ObjectName + '/');
					setStatus('Folder moved', true);
					load()
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(move);
			let del = document.createElement('button');
			del.className = 'danger';
			del.textContent = 'Delete';
			del.onclick = async () => {
				if(!confirm('Delete folder and all contents?')) return;
				setStatus('Deleting...', true);
				try {
					await deleteFolderRecursively(currentPath + item.ObjectName + '/');
					setStatus('Folder deleted', true);
					load()
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(del)
		} else {
			let download = document.createElement('button');
			download.textContent = 'Download';
			download.onclick = async () => {
				try {
					setStatus('Preparing download...', true);
					let blob = await downloadFile(currentPath + item.ObjectName);
					let a = document.createElement('a');
					a.href = URL.createObjectURL(blob);
					a.download = item.ObjectName;
					document.body.appendChild(a);
					a.click();
					a.remove();
					URL.revokeObjectURL(a.href);
					setStatus('Download started', true)
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(download);
			let rename = document.createElement('button');
			rename.textContent = 'Rename';
			rename.onclick = async () => {
				let nn = prompt('New file name', item.ObjectName);
				if(!nn || nn === item.ObjectName) return;
				setStatus('Renaming...', true);
				try {
					await moveFile(currentPath + item.ObjectName, currentPath + nn);
					setStatus('File renamed', true);
					load()
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(rename);
			let move = document.createElement('button');
			move.textContent = 'Move';
			move.onclick = async () => {
				let dest = prompt('Destination folder relative to ' + CONFIG.root, '');
				if(dest === null) return;
				dest = dest.trim();
				let destPath = dest ? normPath(CONFIG.root + dest) : currentPath;
				setStatus('Moving file...', true);
				try {
					await moveFile(currentPath + item.ObjectName, destPath + item.ObjectName);
					setStatus('File moved', true);
					load()
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(move);
			let del = document.createElement('button');
			del.className = 'danger';
			del.textContent = 'Delete';
			del.onclick = async () => {
				if(!confirm('Delete file?')) return;
				setStatus('Deleting...', true);
				try {
					await deleteFile(currentPath + item.ObjectName);
					setStatus('File deleted', true);
					load()
				} catch (e) {
					setStatus(String(e))
				}
			};
			wrap.appendChild(del)
		}
		return wrap
	}

	function render(items) {
		tbody.innerHTML = '';
		renderBreadcrumb();
		if(!Array.isArray(items) || !items.length) {
			let tr = document.createElement('tr');
			let td = document.createElement('td');
			td.colSpan = 5;
			td.style.color = '#888';
			td.textContent = 'Empty';
			tr.appendChild(td);
			tbody.appendChild(tr);
			return
		}
		items.sort((a, b) => Number(b.IsDirectory) - Number(a.IsDirectory) || a.ObjectName.localeCompare(b.ObjectName))
		 for(let it of items) {
			let tr = document.createElement('tr');
			let nameTd = document.createElement('td');
			let row = document.createElement('div');
			row.className = 'row-title';
			let icon = document.createElement('span');
			icon.className = 'icon ' + (it.IsDirectory ? 'folder' : 'file');
			row.appendChild(icon);
			let name = document.createElement('span');
			name.textContent = it.ObjectName;
			row.appendChild(name);
			nameTd.appendChild(row);
			tr.appendChild(nameTd);
			let typeTd = document.createElement('td');
			typeTd.innerHTML = it.IsDirectory ? '<span class="badge">Folder</span>' : '<span class="badge">File</span>';
			tr.appendChild(typeTd);
			let sizeTd = document.createElement('td');
			sizeTd.className = 'size';
			sizeTd.textContent = it.IsDirectory ? '' : formatBytes(it.Length);
			tr.appendChild(sizeTd);
			let dateTd = document.createElement('td');
			dateTd.textContent = formatDate(it.LastChanged);
			tr.appendChild(dateTd);
			let actionsTd = document.createElement('td');
			actionsTd.appendChild(rowActions(it, it.IsDirectory));
			tr.appendChild(actionsTd);
			tbody.appendChild(tr)
		}
	}
	async function load() {
		setStatus('Loading...', true);
		try {
			let data = await list(currentPath);
			render(data);
			setStatus('')
		} catch (e) {
			setStatus(String(e))
		}
	}
	document.getElementById('btnRefresh').onclick = () => load() document.getElementById('btnUp').onclick = () => {
		let p = parentPath(currentPath);
		if(p === currentPath) return;
		currentPath = p;
		load()
	}
	document.getElementById('btnNewFolder').onclick = async () => {
		let name = prompt('Folder name');
		if(!name) return;
		name = name.trim();
		if(!name) return;
		setStatus('Creating folder...', true);
		try {
			await createDir(currentPath + name + '/');
			setStatus('Folder created', true);
			load()
		} catch (e) {
			setStatus(String(e))
		}
	}
	document.getElementById('btnUpload').onclick = () => fileInput.click() fileInput.onchange = async (e) => {
		let files = [...e.target.files];
		if(!files.length) return;
		let total = files.reduce((a, f) => a + f.size, 0);
		let done = 0;
		showProgress(0);
		setStatus('Uploading...', true);
		for(let f of files) {
			try {
				await uploadFile(currentPath + f.name, f, p => {
					let prev = done + Math.floor(f.size * (p / 100));
					let overall = 100 * (prev / Math.max(1, total));
					showProgress(overall)
				});
				done += f.size;
				showProgress(100 * (done / Math.max(1, total)))
			} catch (err) {
				setStatus('Upload failed: ' + err);
				showProgress(null);
				return
			}
		}
		setStatus('Upload complete', true);
		showProgress(null);
		fileInput.value = '';
		load()
	}
	load()
	</script>
</body>

</html>
